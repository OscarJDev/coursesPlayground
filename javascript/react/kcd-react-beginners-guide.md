# Beginners Guide To React

## Introduction

We will eventually need to spin up a server to complete some lectures. In order to do this, we can easily implement browser-sync using the folowing node command:

  ```powershell
    # We may be required to install browser-sync as a dependency
    npx browser-sync start --server --files "./*.html" --no-open --no-notify --directory
  ```

## Create a User Interface in JS

To create a user interface in JS we need to have a root DOM  node into which append our JavaScript generate DOM objects. We have to access this root element and create new elements to append to it using the `document` APIs from the browser.

## Create a User Interface with React's createElement API

For the purposes of the exercises, React and ReactDOM are going to be added into the global/window object by means of `<script>`s tags. We can access CDN links though *unpkg.com* for React and ReactDOM.

  ```html
    <script src="https://unpkg.com/react@16.12.0/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16.12.0/umd/react-dom.developoment.js"></script>
  ```

  - The `React.createElement()` method returns an object with different properties like the following:

  ```javascript
    {
      $$typeof: Symbol(react.element),
      key: null,
      props: {children: "Hello"},
      ref: null,
      type: "div",
      _owner: null,
      _store: {validated: false},
      _self: null,
      _source: null,
      __proto__: Object
    }
  ```

  - It takes the type of HTML element to create, an object with properties for that element, commonly known as the 'component props' and the element's children as arguments: `React.createElement('div', {className, id, ...}, children)`.

## Create a User Interface with React JSX Syntax

The way React's is commonly implemented in the community is by using `JSX` which is an HTML-like syntax in JavaScript.

  - JSX syntax has to be compiled to something that browser can understand. This is where a compiler like Babel comes into play. It Takes the JS/JSX code and compiles it into plain JS code, which can be fully understood by the browser.
  - As with React and React-DOM, we can add a `<script>` tag referencing to the CDN provided for Babel in *unpkg.com*:

  ```html
    <script src="https://unpkg.com/@babe/standalone@7.8.3/babel.js"></script>
  ```

  - Babel is going to look for any `<script>`s with a type of `text/babel` in order to compile it into JS syntax compatible with the browser. The compiled version of our code is going to be automatically added on to our page through a `<script>` block with the transpiled code generated by Babel (HTML-syntax to JS (React APIs) syntax).

  - JSX syntax allows the usage of plain JS wrapping the code to be evaluated directly as JS with `{}`. The key/value pairs we typically set in HTML are going to be compile into the props object for the component in JS-React APIs.
    - We can have self-closing tags with JSX. Also, because the attributes on a JSX HTML-like element are compiled to the props object for `React.createElement()`, we can leverage the usage of the object spread `...` operator. 

## Render Elements side-by-side with React Fragments

In order to pass multiple sibling elements into a `React.createElement()` call, React provides a wrapping element type called 'Fragment'. This is really useful when grouping blocks of HTML markup for tables, for example, without adding additional markup. We can implement them by passing the elements to group into a `React.Fragment` element type (as first element to a `React.createElement()` call).

  - The usage of Fragments save us the trouble of creating a container element (like a div), to group sibling elements we intend to render on the page.
  - Because it's widely usage during development, JSX introduce a shorter syntax for them (the original JSX is `<React.Fragment></React.Fragment>`):

  ```jsx
    <> // The shorter syntax doesn't require to have the React.fragment inside of the angle brackets
      <span>Hello</span>
      <span>World</span>
    </>
  ```

## Create a Reusable React Component

In order to avoid repetition, we can create functions that return JSX elements. These functions become React components, and as suck, they receive in props. Props can be manipulated though the first parameter to the React component.

  - It is a common practice to define React components with capitalized (as if they were classes) labels and using arrow functions (lambdas). Using capitalized labels for React components instruct JSX that we want to create React element using a reference to the React component created, instead of a DOM element named as lowecased element (for example, 'message' would be treated as a reference to a `<message></message>` HTML element; 'Message', on the other hand, as a reference to a declared function).

  ```jsx
    const Message = props => <div className="message">{props.children}</div>
  ```

  - It is important to remember that both 'children' and 'className' are prop names reserved by React. Whatever is enclosed by JSX element tags is considered as the props.children of it.

## Validate Custom React Components Props with PropTypes

Our custom functional components may not be used correctly after creating them, either by us or another person. Because of this, React added support to functional components' type checking at runtime to validate the props passed to our custom components.

  - We have to add a 'propTypes' property to the functional component, which has to be an object with methods named as the props of the component. The process is shown as follows:

  ```jsx
    const SayHello = ({firstName, lastName}) => (
      <div>Hello {firstName} {lastName}!</div>
    )

    SayHello.propTypes = {
      firstname(props, propName, componentName) {
        /* 
          Logic to validate props being passed to the component:
            - 'props' is an object containing all the props passed to the component.
            - 'propName' holds the name for each specific prop been validated.
            - 'componentName'... 
          All type checker functions have to return undefined/null or an Error.
        */
      },
      lastname(props, propName, componentName) { /* ... */ }
    }
    /* 
      An abstraction to the previously defined:
      const propTypes = {
        string(props, propName, componentName) {
          if(typeof(props[propName]) !== 'string') {
            const error = `The "${propName}" prop has to be a string in the ${componentName} component, but you passed a ${typeof props[propName]} value`
            return new Error(error)
          }
        }
      }
      SayHello.propTypes = {
        firstName: propTypes.string,
        lastName: propTypes.string
        }
    */
  ```

  - prop type checking is so common during development that the React team developed a package called 'prop-types' to ease the validation process setup. We can grab the CDN link from *unpkg.com* and add a `<script>` tag to include it as before. This way we are going to have the `PropType` object defined as a global variable, basically containing a lot of type checker functions similar to the `string` method defined in the `propTypes` object abstraction from above.

> When specifying `propTypes`, a fair amount of code needs to be run whenever React mounts our components, which *may* impact application performance. We can skip the running of the `propTypes` related code using the production build of React or a babel plugin called 'babel-plugin-transform-react-remove-prop-types' (this plugin is going to remove 'unnecessary' React `propTypes` from the production build). Many toolkits/bundlers have this plugin included (or use a similar approach) by default.

## Understanding and Using Interpolation in JSX

We can have nested/interchangeably combinations of JSX/JS syntax evaluation in the code compiled by Babel.

  - Each time we hit an JSX element's opening tag (`<element>`) we tell Babel that the following code should be compiled as JSX syntax. This JSX considerations are going to persist until the corresponding element's closing tag is parsed (in which case Babel will return to JS land) OR and opening curly brace is parsed (`{`). If the latter happens, Babel will evaluate/compile code as a limited version of JS (only expressions are allowed here, i.e. only primitive values, ternary operators, IIFE, and so on). This parsing considerations can be repeated several times.

## Rerender a React Application

React provides some optimization to our application, enhancing performance. Only the components whose properties change are going to be re-rendered. This aids the performance and the accessibility on our apps; focus can be tracked because the whole app is not re-render between component updates, only the ones who needs to be updated.

## Style React Components with className and inline Styles

To apply styles to our React components, we can set class and id attributes to the JSX syntax that will be compiled into properties to the props object passed to `React.createElement()`. Additionally, inline styles can be applied with the reserved key prop `styles` in React.

  - It is important to remember that because JSX is compiled to JS and not HTML, we have to use `className` instead of `class` when defining a class for the element (this is due to conflicts with the `class` keyword in JS. This happens with other keywords as well).

## Use Event Handlers with React

React makes some serious optimization on the DOM native events. Our event handlers receive what is called a `SyntheticEvent` object. The native event, although not commonly accessed, it is contained inside the syntethic event.

## Manage State in a React Component with the useState Hook

To manage state in a React component we make use of the `useState()` hook function from the `React` library. It takes an initial value to be used when mounting the component, and returns and array with a variable holding the current value of the state tracked and a function to update it.

  - We could set a variable in the closure of the function component to track state and a function to modify it given some DOM event. However, this state setting won't be triggering a re-render of the component by itself, and if we configure it to do so, the whole component would be re-rendered, resetting the value of the state variable to the initial one give it by us at function declaration time (the value set with the function to update the state would be garbage collected)

`React.useState()` was created with some perfomance optimization to remedy the case above:

  - Initial state values are used only when the component is mounted.
  - Updated values will be tracked between re-renders, allowing us to modify state without resetting issues.
  - Only the DOM elements rendered consuming the given state are going to be re-rendered when that state is changed/updated.

## Manage Side-Effects in a React Component with the useEffect Hook

The `useEffect()` hook is used to perform side-effect operations. We passed to it a callback with all the side effects we want to execute. This callback is going to be ***invoked always after*** the component is mounted, and on some re-renders depending on the 2nd argument passed to this hook, which can take the following values:

`useEffect()` 2nd argument | callback execution considerations
`undefined` | Callback is executed after the component is mounted and with every re-render.
`[]` (empty dependency array) | Callback is executed only when the component is mounted.
`[val1, val2, ...valN]` | Callback is executed when the component is mounted and with every re-render triggered by values listed inside the dependency array.

  - It is important to note that unmounting can also be handled with the callback passed to the `useEffect()` hook, especifically with its return statement. The return value should typically be a callback as well.

## Use a Lazy Initializer with useState

The initial value for a piece of state it is necessary when the component declaring it is mounted for the first time. If a value is passed directly as the argument to `useState()` hook, it will be computed on the when component mounts and with each subsequent re-render of the component. However, after mounting the component for the first time, this initial value is not needed anymore, so its computation could lead to performance issues when the computational resources needed for this are important (parsing a JSON value, for example). 

  - We can wrap the initial value passed to `useState()` hook with a callback that will get invoked and return that value only when the value is needed (when component is mounted, not re-rendered).
  - It is important to note that the value computation is inteded to be synchronous!

## Manage the useEffect Dependency Array

React's `useEffect()` hooks will *eagerly* attempt to synchronize the "state of the world" with the state of the application. This normally won't lead to bugs (in fact, is does a great job at preventing bugs that plagued React apps before `useEffect` was available), but it can definitely be sub-optimal (and in some cases can result in an infinite-loop).

To prevent unnecessary calls to the effect callback we can use the dependency array which `useEffect()` optionally takes as second argument. There are some rules we can set on ESlint  (though usage of the "eslint-plugin-react-hooks") to help us define all hooks properly/effectively when developing real applications (many tools like Create React App have this installed and configured by default).

## Create Reusable Custom Hooks

We can share our hooks logic implementation (in this case storing a piece of state in the browser local storage) between different components or even with different variables within the same component. This can be done simply by wrapping hooks logic inside a function an abstract it from the original component implmenting it. This is very easy to do because the way hooks's API is designed, following a simple vanilla JavaScript approach.

When such hook abstractions are created, we are creating what's commonly known as Custom Hooks. These hooks should follow a naming convention in order for us to take advantage of some tools created by the React team such as the eslint-plugin-react-hooks plugin, which detects any function whose name is prefixed with the word 'use' to enforce some React hooks conventions and best practices.

## Manipulate the DOM with React refs

Because the JSX elements we return from a component are not DOM elements by itself but React elements that are going to be rendered to the DOM, ot get access to the DOM elements rendered later on, React uses a `ref` prop where we can pass a value to hold a reference to the DOM element after its rendering. This value can then be use to manipulate the rendered element from outside React, meaning that we could modify it without executing a re-render of the element by React.

  - React provides another hook to create a value to use as a ref holder, the `React.useRef()`, which return an object with a `current` property in it that will hold any given node referenced by the hook after it is mounted in the DOM

  ```javascript
  function Tilt({childre}) {
    const tiltRef = React.useRef()
    
    React.useEffect(()=>{
      const tiltNode = tiltRef.current // tiltNode now becomes a reference to the DOM element rendered!
      // Side effects to perform (Manipulating the DOM is a side effect)...
      return () =>{
        // cleanup code to be run when unmounting the DOM element
      }
    })

    return (
      <div ref={tiltRef}>
        <div>{children}</div>
      </div>
    )
  }
  ```

  - `React.useEffect()` can take an argument that we can use as initial value to the `current` property on the ref object return.
  - The `current` property it is only set after the DOM element, which gets passed the ref object, is mounted. The callback passed to `React.useEffect()` is used to set and manipulate this ref value because of its execution after the DOM element is mounted.
  - Be aware that even when a DOM element is removed from the page, references to it and event handlers would still persist in memory. This could become a performance issue with subsequent mounts and unmounts of it. We need to make sure to perform the clean up work after the dom is removed from the page, which can be achieved through the return callback of the callback passed to `React.useEffect()`.

## Understand the React Hook Flow

Understanding the order in which React hooks are called can be really beneficial to the way in which we implement the logic inside our components.

Different component's lifecycle triggers the execution of React hooks callbacks in various ways. Some considerations to keep in mind are:

  - Callback passed into `React.useState()` hook is going to be run only when component mounts in order to obtain an initial value from it. Further re-renders of the component will not run it and will handle previous state values (this is not true when an expression is passed, in which case it will be computed on mounting and with every re-render).
  - Callback passed to `React.useEffect()` will be run after the component mounts on the page. Further invocations of the callback on re-renders will depend on a dependency array being passed as a second argument to `React.useEffect()` or not. When a component unmounts, the return callback of the effect function is usually run to perform clean up works to improve memory performance.
    - No dependency list will make the callback to be run on component mounting, re-rendering and unmounting
    - An empty dependency list passed makes the callback to be called on mount and unmounting only.
    - A dependency list with values in it signifies the callback will be run always on mounting, but also on re-renders provoked by changes in any value listed on the dependency array. 
      - Unmounting will follow the same behaviour as well; fully unmounting (entirely removing) a component from page or when re-rendering a component because a value in the list changes.
    - Note that side effects (`React.useEffect()` callbacks) from child components are run first than parent's after rendering elements on the page. The same goes for side effects's clean up callbacks; clean up is run before running new side effects callbacks. 

The following diagram can be usefull to clarify the way hooks are invoked depending of component's lifecycle:

![Hooks Flow](18-hook-flow.png)

## Make Basic Forms with React



## Make Dynamic Forms with React

## Controlling Form Values with React

## Using React Error Boundaries to Handle Errors in React Components