# Beginners Guide To React

## Introduction

We will eventually need to spin up a server to complete some lectures. In order to do this, we can easily implement browser-sync using the folowing node command:

  ```powershell
    # We may be required to install browser-sync as a dependency
    npx browser-sync start --server --files "./*.html" --no-open --no-notify --directory
  ```

## Create a User Interface in JS

To create a user interface in JS we need to have a root DOM  node into which append our JavaScript generate DOM objects. We have to access this root element and create new elements to append to it using the `document` APIs from the browser.

## Create a User Interface with React's createElement API

For the purposes of the exercises, React and ReactDOM are going to be added into the global/window object by means of `<script>`s tags. We can access CDN links though *unpkg.com* for React and ReactDOM.

  ```html
    <script src="https://unpkg.com/react@16.12.0/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16.12.0/umd/react-dom.developoment.js"></script>
  ```

  - The `React.createElement()` method returns an object with different properties like the following:

  ```javascript
    {
      $$typeof: Symbol(react.element),
      key: null,
      props: {children: "Hello"},
      ref: null,
      type: "div",
      _owner: null,
      _store: {validated: false},
      _self: null,
      _source: null,
      __proto__: Object
    }
  ```

  - It takes the type of HTML element to create, an object with properties for that element, commonly known as the 'component props' and the element's children as arguments: `React.createElement('div', {className, id, ...}, children)`.

## Create a User Interface with React JSX Syntax

The way React's is commonly implemented in the community is by using `JSX` which is an HTML-like syntax in JavaScript.

  - JSX syntax has to be compiled to something that browser can understand. This is where a compiler like Babel comes into play. It Takes the JS/JSX code and compiles it into plain JS code, which can be fully understood by the browser.
  - As with React and React-DOM, we can add a `<script>` tag referencing to the CDN provided for Babel in *unpkg.com*:

  ```html
    <script src="https://unpkg.com/@babe/standalone@7.8.3/babel.js"></script>
  ```

  - Babel is going to look for any `<script>`s with a type of `text/babel` in order to compile it into JS syntax compatible with the browser. The compiled version of our code is going to be automatically added on to our page through a `<script>` block with the transpiled code generated by Babel (HTML-syntax to JS (React APIs) syntax).

  - JSX syntax allows the usage of plain JS wrapping the code to be evaluated directly as JS with `{}`. The key/value pairs we typically set in HTML are going to be compile into the props object for the component in JS-React APIs.
    - We can have self-closing tags with JSX. Also, because the attributes on a JSX HTML-like element are compiled to the props object for `React.createElement()`, we can leverage the usage of the object spread `...` operator. 

## Render Elements side-by-side with React Fragments

In order to pass multiple sibling elements into a `React.createElement()` call, React provides a wrapping element type called 'Fragment'. This is really useful when grouping blocks of HTML markup for tables, for example, without adding additional markup. We can implement them by passing the elements to group into a `React.Fragment` element type (as first element to a `React.createElement()` call).

  - The usage of Fragments save us the trouble of creating a container element (like a div), to group sibling elements we intend to render on the page.
  - Because it's widely usage during development, JSX introduce a shorter syntax for them (the original JSX is `<React.Fragment></React.Fragment>`):

  ```jsx
    <> // The shorter syntax doesn't require to have the React.fragment inside of the angle brackets
      <span>Hello</span>
      <span>World</span>
    </>
  ```

## Create a Reusable React Component

In order to avoid repetition, we can create functions that return JSX elements. These functions become React components, and as suck, they receive in props. Props can be manipulated though the first parameter to the React component.

  - It is a common practice to define React components with capitalized (as if they were classes) labels and using arrow functions (lambdas). Using capitalized labels for React components instruct JSX that we want to create React element using a reference to the React component created, instead of a DOM element named as lowecased element (for example, 'message' would be treated as a reference to a `<message></message>` HTML element; 'Message', on the other hand, as a reference to a declared function).

  ```jsx
    const Message = props => <div className="message">{props.children}</div>
  ```

  - It is important to remember that both 'children' and 'className' are prop names reserved by React. Whatever is enclosed by JSX element tags is considered as the props.children of it.

## Validate Custom React Components Props with PropTypes

Our custom functional components may not be used correctly after creating them, either by us or another person. Because of this, React added support to functional components' type checking at runtime to validate the props passed to our custom components.

  - We have to add a 'propTypes' property to the functional component, which has to be an object with methods named as the props of the component. The process is shown as follows:

  ```jsx
    const SayHello = ({firstName, lastName}) => (
      <div>Hello {firstName} {lastName}!</div>
    )

    SayHello.propTypes = {
      firstname(props, propName, componentName) {
        /* 
          Logic to validate props being passed to the component:
            - 'props' is an object containing all the props passed to the component.
            - 'propName' holds the name for each specific prop been validated.
            - 'componentName'... 
          All type checker functions have to return undefined/null or an Error.
        */
      },
      lastname(props, propName, componentName) { /* ... */ }
    }
    /* 
      An abstraction to the previously defined:
      const propTypes = {
        string(props, propName, componentName) {
          if(typeof(props[propName]) !== 'string') {
            const error = `The "${propName}" prop has to be a string in the ${componentName} component, but you passed a ${typeof props[propName]} value`
            return new Error(error)
          }
        }
      }
      SayHello.propTypes = {
        firstName: propTypes.string,
        lastName: propTypes.string
        }
    */
  ```

  - prop type checking is so common during development that the React team developed a package called 'prop-types' to ease the validation process setup. We can grab the CDN link from *unpkg.com* and add a `<script>` tag to include it as before. This way we are going to have the `PropType` object defined as a global variable, basically containing a lot of type checker functions similar to the `string` method defined in the `propTypes` object abstraction from above.

> When specifying `propTypes`, a fair amount of code needs to be run whenever React mounts our components, which *may* impact application performance. We can skip the running of the `propTypes` related code using the production build of React or a babel plugin called 'babel-plugin-transform-react-remove-prop-types' (this plugin is going to remove 'unnecessary' React `propTypes` from the production build). Many toolkits/bundlers have this plugin included (or use a similar approach) by default.

## Understanding and Using Interpolation in JSX

We can have nested/interchangeably combinations of JSX/JS syntax evaluation in the code compiled by Babel.

  - Each time we hit an JSX element's opening tag (`<element>`) we tell Babel that the following code should be compiled as JSX syntax. This JSX considerations are going to persist until the corresponding element's closing tag is parsed (in which case Babel will return to JS land) OR and opening curly brace is parsed (`{`). If the latter happens, Babel will evaluate/compile code as a limited version of JS (only expressions are allowed here, i.e. only primitive values, ternary operators, IIFE, and so on). This parsing considerations can be repeated several times.

## Rerender a React Application

React provides some optimization to our application, enhancing performance. Only the components whose properties change are going to be re-rendered. This aids the performance and the accessibility on our apps; focus can be tracked because the whole app is not re-render between component updates, only the ones who needs to be updated.

## Style React Components with className and inline Styles

To apply styles to our React components, we can set class and id attributes to the JSX syntax that will be compiled into properties to the props object passed to `React.createElement()`. Additionally, inline styles can be applied with the reserved key prop `styles` in React.

  - It is important to remember that because JSX is compiled to JS and not HTML, we have to use `className` instead of `class` when defining a class for the element (this is due to conflicts with the `class` keyword in JS. This happens with other keywords as well).

## Use Event Handlers with React

React makes some serious optimization on the DOM native events. Our event handlers receive what is called a `SyntheticEvent` object. The native event, although not commonly accessed, it is contained inside the syntethic event.

## Manage State in a React Component with the useState Hook

To manage state in a React component we make use of the `useState()` hook function from the `React` library. It takes an initial value to be used when mounting the component, and returns and array with a variable holding the current value of the state tracked and a function to update it.

  - We could set a variable in the closure of the function component to track state and a function to modify it given some DOM event. However, this state setting won't be triggering a re-render of the component by itself, and if we configure it to do so, the whole component would be re-rendered, resetting the value of the state variable to the initial one give it by us at function declaration time (the value set with the function to update the state would be garbage collected)

`React.useState()` was created with some perfomance optimization to remedy the case above:

  - Initial state values are used only when the component is mounted.
  - Updated values will be tracked between re-renders, allowing us to modify state without resetting issues.
  - Only the DOM elements rendered consuming the given state are going to be re-rendered when that state is changed/updated.

## Manage Side-Effects in a React Component with the useEffect Hook

The `useEffect()` hook is used to perform side-effect operations. We passed to it a callback with all the side effects we want to execute. This callback is going to be ***invoked always after*** the component is mounted, and on some re-renders depending on the 2nd argument passed to this hook, which can take the following values:

`useEffect()` 2nd argument | callback execution considerations
`undefined` | Callback is executed after the component is mounted and with every re-render.
`[]` (empty dependency array) | Callback is executed only when the component is mounted.
`[val1, val2, ...valN]` | Callback is executed when the component is mounted and with every re-render triggered by values listed inside the dependency array.

  - It is important to note that unmounting can also be handled with the callback passed to the `useEffect()` hook, especifically with its return statement.

## Use a Lazy Initializer with useState

The initial value for a piece of state it is necessary when the component declaring it is mounted for the first time. If a value is passed directly as the argument to `useState()` hook, it will be computed on the initial render and with each subsequent re-render of the component. However, after the first render of the component, this initial value is not needed, so its computation could lead to performance issues when the computational resources needed for this are important (parsing a JSON value, for example). 

  - We can wrap the initial value passed to `useState()` hook with a callback that will get computed only when the value is needed (just when component is mounted, not re-rendered).
  - It is important to note that the value computation is inteded to be synchronous!

## Manage the useEffect Dependency Array

React's `useEffect()` hooks will *eagerly* attempt to synchronize the "state of the world" with the state of the application. This normally won't lead to bugs (in fact, is does a great job at preventing bugs that plagued React apps before `useEffect` was available), but it can definitely be sub-optimal (and in some cases can result in an infinite-loop).

To prevent unnecessary calls to the effect callback we can use the dependency array which `useEffect()` optionally takes as second argument. There are some rules we can set on ESlint  (though usage of the "eslint-plugin-react-hooks") to help us define all hooks properly/effectively when developing real applications (many tools like Create React App have this installed and configured by default).